// This file was automatically generated by Beschi v0.1.12
// <https://github.com/sjml/beschi>
// Do not edit directly.

package AppMessages

import (
	"encoding/binary"
	"io"
)

func readString(data io.Reader, str *string) error {
	var len byte
	binary.Read(data, binary.LittleEndian, &len)
	sbytes := make([]byte, len)
	err := binary.Read(data, binary.LittleEndian, &sbytes)
	if err != nil {
		panic(err)
	}
	*str = string(sbytes)
	return err
}

func writeString(data io.Writer, str *string) {
	strLen := (byte)(len(*str))
	binary.Write(data, binary.LittleEndian, strLen)
	io.WriteString(data, *str)
}

type MessageType byte
const (
	Vector3MessageType MessageType = 1
	NewCharacterMessageType MessageType = 2
	CharacterJoinedTeamType MessageType = 3
)

type Message interface {
	GetMessageType() MessageType
	WriteBytes(data io.Writer, tag bool)
	GetSizeInBytes() int
}

func ProcessRawBytes (data io.Reader) []Message {
	var msgList []Message
	var err error
	for err != io.EOF {
		var msgType MessageType
		err = binary.Read(data, binary.LittleEndian, &msgType)
		if err == io.EOF {
			break
		}
		switch msgType {
		case Vector3MessageType:
			msgList = append(msgList, Vector3MessageFromBytes(data))
		case NewCharacterMessageType:
			msgList = append(msgList, NewCharacterMessageFromBytes(data))
		case CharacterJoinedTeamType:
			msgList = append(msgList, CharacterJoinedTeamFromBytes(data))
		default:
			msgList = append(msgList, nil)
		}
		if msgList[len(msgList)-1] == nil {
			break
		}
	}
	return msgList
}

type Color struct {
	Red float32
	Green float32
	Blue float32
	Alpha float32
}

func ColorFromBytes (data io.Reader, input *Color) {
	var err error
	err = nil
	err = binary.Read(data, binary.LittleEndian, &input.Red)
	if err != nil {
		panic(err)
	}
	err = binary.Read(data, binary.LittleEndian, &input.Green)
	if err != nil {
		panic(err)
	}
	err = binary.Read(data, binary.LittleEndian, &input.Blue)
	if err != nil {
		panic(err)
	}
	err = binary.Read(data, binary.LittleEndian, &input.Alpha)
	if err != nil {
		panic(err)
	}
	if err != nil {
		panic(err)
	}
}

func (output Color) WriteBytes (data io.Writer) {
	binary.Write(data, binary.LittleEndian, &output.Red)
	binary.Write(data, binary.LittleEndian, &output.Green)
	binary.Write(data, binary.LittleEndian, &output.Blue)
	binary.Write(data, binary.LittleEndian, &output.Alpha)
}

type Spectrum struct {
	DefaultColor Color
	Colors []Color
}

func SpectrumFromBytes (data io.Reader, input *Spectrum) {
	var err error
	err = nil
	err = binary.Read(data, binary.LittleEndian, &input.DefaultColor)
	if err != nil {
		panic(err)
	}
	var Colors_Len uint16
	err = binary.Read(data, binary.LittleEndian, &Colors_Len)
	if err != nil {
		panic(err)
	}
	input.Colors = make([]Color, Colors_Len)
	for i1 := (uint16)(0); i1 < Colors_Len; i1++ {
		err = binary.Read(data, binary.LittleEndian, &input.Colors[i1])
		if err != nil {
			panic(err)
		}
	}
	if err != nil {
		panic(err)
	}
}

func (output Spectrum) WriteBytes (data io.Writer) {
	binary.Write(data, binary.LittleEndian, &output.DefaultColor)
	Colors_Len := (uint16)(len(output.Colors))
	binary.Write(data, binary.LittleEndian, Colors_Len)
	for i1 := (uint16)(0); i1 < Colors_Len; i1++ {
		binary.Write(data, binary.LittleEndian, &output.Colors[i1])
	}
}

type Vector3Message struct {
	X float32
	Y float32
	Z float32
}

func (output Vector3Message) GetMessageType() MessageType {
	return Vector3MessageType
}

func (output Vector3Message) GetSizeInBytes() int {
	return 12
}
func Vector3MessageFromBytes (data io.Reader) (msg *Vector3Message) {
	defer func() {
		if r := recover(); r != nil {
			msg = nil
		}
	}()
	var err error
	err = nil
	ret := Vector3Message{}
	err = binary.Read(data, binary.LittleEndian, &ret.X)
	if err != nil {
		panic(err)
	}
	err = binary.Read(data, binary.LittleEndian, &ret.Y)
	if err != nil {
		panic(err)
	}
	err = binary.Read(data, binary.LittleEndian, &ret.Z)
	if err != nil {
		panic(err)
	}
	if err != nil {
		panic(err)
	}

	return &ret
}

func (output Vector3Message) WriteBytes (data io.Writer, tag bool) {
	if tag {
		binary.Write(data, binary.LittleEndian, Vector3MessageType)
	}
	binary.Write(data, binary.LittleEndian, &output.X)
	binary.Write(data, binary.LittleEndian, &output.Y)
	binary.Write(data, binary.LittleEndian, &output.Z)
}

type NewCharacterMessage struct {
	Id uint64
	CharacterName string
	Strength uint16
	Intelligence uint16
	Dexterity uint16
	GoldInWallet uint32
	Nicknames []string
}

func (output NewCharacterMessage) GetMessageType() MessageType {
	return NewCharacterMessageType
}

func (output NewCharacterMessage) GetSizeInBytes() int {
	size := 0
	size += len(output.CharacterName)
	for _, s := range output.Nicknames {
		size += 1 + len(s)
	}
	size += 21
	return size
}
func NewCharacterMessageFromBytes (data io.Reader) (msg *NewCharacterMessage) {
	defer func() {
		if r := recover(); r != nil {
			msg = nil
		}
	}()
	var err error
	err = nil
	ret := NewCharacterMessage{}
	err = binary.Read(data, binary.LittleEndian, &ret.Id)
	if err != nil {
		panic(err)
	}
	err = readString(data, &ret.CharacterName)
	if err != nil {
		panic(err)
	}
	err = binary.Read(data, binary.LittleEndian, &ret.Strength)
	if err != nil {
		panic(err)
	}
	err = binary.Read(data, binary.LittleEndian, &ret.Intelligence)
	if err != nil {
		panic(err)
	}
	err = binary.Read(data, binary.LittleEndian, &ret.Dexterity)
	if err != nil {
		panic(err)
	}
	err = binary.Read(data, binary.LittleEndian, &ret.GoldInWallet)
	if err != nil {
		panic(err)
	}
	var Nicknames_Len uint16
	err = binary.Read(data, binary.LittleEndian, &Nicknames_Len)
	if err != nil {
		panic(err)
	}
	ret.Nicknames = make([]string, Nicknames_Len)
	for i1 := (uint16)(0); i1 < Nicknames_Len; i1++ {
		err = readString(data, &ret.Nicknames[i1])
		if err != nil {
			panic(err)
		}
	}
	if err != nil {
		panic(err)
	}

	return &ret
}

func (output NewCharacterMessage) WriteBytes (data io.Writer, tag bool) {
	if tag {
		binary.Write(data, binary.LittleEndian, NewCharacterMessageType)
	}
	binary.Write(data, binary.LittleEndian, &output.Id)
	writeString(data, &output.CharacterName)
	binary.Write(data, binary.LittleEndian, &output.Strength)
	binary.Write(data, binary.LittleEndian, &output.Intelligence)
	binary.Write(data, binary.LittleEndian, &output.Dexterity)
	binary.Write(data, binary.LittleEndian, &output.GoldInWallet)
	Nicknames_Len := (uint16)(len(output.Nicknames))
	binary.Write(data, binary.LittleEndian, Nicknames_Len)
	for i1 := (uint16)(0); i1 < Nicknames_Len; i1++ {
		writeString(data, &output.Nicknames[i1])
	}
}

type CharacterJoinedTeam struct {
	CharacterID uint64
	TeamName string
	TeamColors []Color
}

func (output CharacterJoinedTeam) GetMessageType() MessageType {
	return CharacterJoinedTeamType
}

func (output CharacterJoinedTeam) GetSizeInBytes() int {
	size := 0
	size += len(output.TeamName)
	size += len(output.TeamColors) * 16
	size += 11
	return size
}
func CharacterJoinedTeamFromBytes (data io.Reader) (msg *CharacterJoinedTeam) {
	defer func() {
		if r := recover(); r != nil {
			msg = nil
		}
	}()
	var err error
	err = nil
	ret := CharacterJoinedTeam{}
	err = binary.Read(data, binary.LittleEndian, &ret.CharacterID)
	if err != nil {
		panic(err)
	}
	err = readString(data, &ret.TeamName)
	if err != nil {
		panic(err)
	}
	var TeamColors_Len uint16
	err = binary.Read(data, binary.LittleEndian, &TeamColors_Len)
	if err != nil {
		panic(err)
	}
	ret.TeamColors = make([]Color, TeamColors_Len)
	for i1 := (uint16)(0); i1 < TeamColors_Len; i1++ {
		err = binary.Read(data, binary.LittleEndian, &ret.TeamColors[i1])
		if err != nil {
			panic(err)
		}
	}
	if err != nil {
		panic(err)
	}

	return &ret
}

func (output CharacterJoinedTeam) WriteBytes (data io.Writer, tag bool) {
	if tag {
		binary.Write(data, binary.LittleEndian, CharacterJoinedTeamType)
	}
	binary.Write(data, binary.LittleEndian, &output.CharacterID)
	writeString(data, &output.TeamName)
	TeamColors_Len := (uint16)(len(output.TeamColors))
	binary.Write(data, binary.LittleEndian, TeamColors_Len)
	for i1 := (uint16)(0); i1 < TeamColors_Len; i1++ {
		binary.Write(data, binary.LittleEndian, &output.TeamColors[i1])
	}
}

