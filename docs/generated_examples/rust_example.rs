// This file was automatically generated by Beschi v0.2.0
// <https://github.com/sjml/beschi>
// Do not edit directly.

use std::fmt;
use std::error::Error;

#[derive(Debug)]
pub enum AppMessagesError {
    EndOfFile,
    InvalidData,
}

impl Error for AppMessagesError {}

impl fmt::Display for AppMessagesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AppMessagesError::EndOfFile => write!(f, "end of file reached prematurely"),
            AppMessagesError::InvalidData => write!(f, "invalid data encountered"),
        }
    }
}

pub struct BufferReader {
    buffer: Vec<u8>,
    current_position: usize,
}

impl BufferReader {
    pub fn new(buffer: Vec<u8>) -> Self {
        BufferReader { buffer, current_position: 0 }
    }

    pub fn is_finished(&self) -> bool {
        if self.current_position >= self.buffer.len() {
            return true
        }
        false
    }

    pub fn has_remaining(&self, size: usize) -> bool {
        if self.current_position + size > self.buffer.len() {
            return false
        }
        true
    }

    pub fn take_byte(&mut self) -> Result<u8, AppMessagesError> {
        if !self.has_remaining(1) {
            return Err(AppMessagesError::EndOfFile);
        }
        self.current_position += 1;
        Ok(self.buffer[self.current_position-1])
    }

    pub fn take(&mut self, amount: usize) -> Result<&[u8], AppMessagesError> {
        if !self.has_remaining(amount) {
            return Err(AppMessagesError::EndOfFile);
        }

        let ret: &[u8] = &self.buffer[self.current_position..self.current_position+amount];
        self.current_position += amount;
        Ok(ret)
    }

    pub fn read_string(&mut self) -> Result<String, AppMessagesError> {
        let len = self.read_u8()?;
        let string_bytes = self.take(len as usize)?;
        match String::from_utf8(string_bytes.to_vec()) {
            Err(_) => Err(AppMessagesError::InvalidData),
            Ok(v) => Ok(v)
        }
    }

    pub fn read_u8(&mut self) -> Result<u8, AppMessagesError> {
        let byte = self.take_byte()?;
        Ok(byte)
    }

    pub fn read_i16(&mut self) -> Result<i16, AppMessagesError> {
        let bytes = self.take(2)?;
        Ok(i16::from_le_bytes(bytes.try_into().unwrap()))
    }

    pub fn read_u16(&mut self) -> Result<u16, AppMessagesError> {
        let bytes = self.take(2)?;
        Ok(u16::from_le_bytes(bytes.try_into().unwrap()))
    }

    pub fn read_i32(&mut self) -> Result<i32, AppMessagesError> {
        let bytes = self.take(4)?;
        Ok(i32::from_le_bytes(bytes.try_into().unwrap()))
    }

    pub fn read_u32(&mut self) -> Result<u32, AppMessagesError> {
        let bytes = self.take(4)?;
        Ok(u32::from_le_bytes(bytes.try_into().unwrap()))
    }

    pub fn read_i64(&mut self) -> Result<i64, AppMessagesError> {
        let bytes = self.take(8)?;
        Ok(i64::from_le_bytes(bytes.try_into().unwrap()))
    }

    pub fn read_u64(&mut self) -> Result<u64, AppMessagesError> {
        let bytes = self.take(8)?;
        Ok(u64::from_le_bytes(bytes.try_into().unwrap()))
    }

    pub fn read_f32(&mut self) -> Result<f32, AppMessagesError> {
        let bytes = self.take(4)?;
        Ok(f32::from_le_bytes(bytes.try_into().unwrap()))
    }

    pub fn read_f64(&mut self) -> Result<f64, AppMessagesError> {
        let bytes = self.take(8)?;
        Ok(f64::from_le_bytes(bytes.try_into().unwrap()))
    }
}

pub enum Message {
    Vector3Message(Vector3Message),
    NewCharacterMessage(NewCharacterMessage),
    CharacterJoinedTeam(CharacterJoinedTeam),
}

pub fn process_raw_bytes(reader: &mut BufferReader) -> Result<Vec<Message>, AppMessagesError> {
    let mut msg_list: Vec<Message> = Vec::new();
    while !reader.is_finished() {
        let msg_type = reader.take_byte()?;
        match msg_type {
            0 => return Ok(msg_list),
            1 => msg_list.push(Message::Vector3Message(Vector3Message::from_bytes(reader)?)),
            2 => msg_list.push(Message::NewCharacterMessage(NewCharacterMessage::from_bytes(reader)?)),
            3 => msg_list.push(Message::CharacterJoinedTeam(CharacterJoinedTeam::from_bytes(reader)?)),
            _ => return Err(AppMessagesError::InvalidData),
        }
    }
    Ok(msg_list)
}

#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum CharacterClass {
    Fighter = 0,
    Wizard = 1,
    Rogue = 2,
    Cleric = 3,
}

impl Default for CharacterClass {
    fn default() -> Self { CharacterClass::Fighter }
}

impl TryFrom<u8> for CharacterClass {
    type Error = AppMessagesError;

    fn try_from(value: u8) -> Result<Self, AppMessagesError> {
        match value {
            0 => Ok(CharacterClass::Fighter),
            1 => Ok(CharacterClass::Wizard),
            2 => Ok(CharacterClass::Rogue),
            3 => Ok(CharacterClass::Cleric),
            _ => Err(AppMessagesError::InvalidData)
        }
    }
}

#[repr(i16)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum TeamRole {
    Minion = 256,
    Ally = 512,
    Leader = 1024,
    Traitor = -1,
}

impl Default for TeamRole {
    fn default() -> Self { TeamRole::Minion }
}

impl TryFrom<i16> for TeamRole {
    type Error = AppMessagesError;

    fn try_from(value: i16) -> Result<Self, AppMessagesError> {
        match value {
            256 => Ok(TeamRole::Minion),
            512 => Ok(TeamRole::Ally),
            1024 => Ok(TeamRole::Leader),
            -1 => Ok(TeamRole::Traitor),
            _ => Err(AppMessagesError::InvalidData)
        }
    }
}

#[derive(Default)]
pub struct Color {
    pub red: f32,
    pub green: f32,
    pub blue: f32,
    pub alpha: f32,
}

impl Color {
    pub fn get_size_in_bytes(&self) -> u32 {
        16
    }

    pub fn from_bytes(reader: &mut BufferReader) -> Result<Color, AppMessagesError> {
        let red = reader.read_f32()?;
        let green = reader.read_f32()?;
        let blue = reader.read_f32()?;
        let alpha = reader.read_f32()?;
        Ok(Color {red, green, blue, alpha})
    }

    pub fn write_bytes(&self, writer: &mut Vec<u8>) {
        writer.extend(self.red.to_le_bytes());
        writer.extend(self.green.to_le_bytes());
        writer.extend(self.blue.to_le_bytes());
        writer.extend(self.alpha.to_le_bytes());
    }
}

#[derive(Default)]
pub struct Spectrum {
    pub default_color: Color,
    pub colors: Vec<Color>,
}

impl Spectrum {
    pub fn get_size_in_bytes(&self) -> u32 {
        let mut size: u32 = 0;
        size += (self.colors.len() as u32) * 16;
        size += 18;
        size
    }

    pub fn from_bytes(reader: &mut BufferReader) -> Result<Spectrum, AppMessagesError> {
        let default_color = Color::from_bytes(reader)?;
        let colors_len = reader.read_u16()?;
        let mut colors: Vec<Color> = Vec::new();
        for _ in 0..colors_len {
            let el = Color::from_bytes(reader)?;
            colors.push(el);
        }
        Ok(Spectrum {default_color, colors})
    }

    pub fn write_bytes(&self, writer: &mut Vec<u8>) {
        self.default_color.write_bytes(writer);
        writer.extend((self.colors.len() as u16).to_le_bytes());
        for el in &self.colors {
            el.write_bytes(writer);
        }
    }
}

#[derive(Default)]
pub struct Vector3Message {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}

impl Vector3Message {
    pub fn get_size_in_bytes(&self) -> u32 {
        12
    }

    pub fn from_bytes(reader: &mut BufferReader) -> Result<Vector3Message, AppMessagesError> {
        let x = reader.read_f32()?;
        let y = reader.read_f32()?;
        let z = reader.read_f32()?;
        Ok(Vector3Message {x, y, z})
    }

    pub fn write_bytes(&self, writer: &mut Vec<u8>, tag: bool) {
        if tag {
            writer.push(1_u8);
        }
        writer.extend(self.x.to_le_bytes());
        writer.extend(self.y.to_le_bytes());
        writer.extend(self.z.to_le_bytes());
    }
}

#[derive(Default)]
pub struct NewCharacterMessage {
    pub id: u64,
    pub character_name: String,
    pub job: CharacterClass,
    pub strength: u16,
    pub intelligence: u16,
    pub dexterity: u16,
    pub wisdom: u16,
    pub gold_in_wallet: u32,
    pub nicknames: Vec<String>,
}

impl NewCharacterMessage {
    pub fn get_size_in_bytes(&self) -> u32 {
        let mut size: u32 = 0;
        size += self.character_name.len() as u32;
        for s in &self.nicknames {
            size += 1 + (s.len() as u32);
        }
        size += 24;
        size
    }

    pub fn from_bytes(reader: &mut BufferReader) -> Result<NewCharacterMessage, AppMessagesError> {
        let id = reader.read_u64()?;
        let character_name = reader.read_string()?;
        let job = reader.read_u8()?;
        let job = CharacterClass::try_from(job)?;
        let strength = reader.read_u16()?;
        let intelligence = reader.read_u16()?;
        let dexterity = reader.read_u16()?;
        let wisdom = reader.read_u16()?;
        let gold_in_wallet = reader.read_u32()?;
        let nicknames_len = reader.read_u16()?;
        let mut nicknames: Vec<String> = Vec::new();
        for _ in 0..nicknames_len {
            let el = reader.read_string()?;
            nicknames.push(el);
        }
        Ok(NewCharacterMessage {id, character_name, job, strength, intelligence, dexterity, wisdom, gold_in_wallet, nicknames})
    }

    pub fn write_bytes(&self, writer: &mut Vec<u8>, tag: bool) {
        if tag {
            writer.push(2_u8);
        }
        writer.extend(self.id.to_le_bytes());
        writer.extend((self.character_name.len() as u8).to_le_bytes());
        writer.extend(self.character_name.as_bytes());
        writer.push(self.job as u8);
        writer.extend(self.strength.to_le_bytes());
        writer.extend(self.intelligence.to_le_bytes());
        writer.extend(self.dexterity.to_le_bytes());
        writer.extend(self.wisdom.to_le_bytes());
        writer.extend(self.gold_in_wallet.to_le_bytes());
        writer.extend((self.nicknames.len() as u16).to_le_bytes());
        for el in &self.nicknames {
            writer.extend((el.len() as u8).to_le_bytes());
            writer.extend(el.as_bytes());
        }
    }
}

#[derive(Default)]
pub struct CharacterJoinedTeam {
    pub character_id: u64,
    pub team_name: String,
    pub team_colors: Vec<Color>,
    pub role: TeamRole,
}

impl CharacterJoinedTeam {
    pub fn get_size_in_bytes(&self) -> u32 {
        let mut size: u32 = 0;
        size += self.team_name.len() as u32;
        size += (self.team_colors.len() as u32) * 16;
        size += 13;
        size
    }

    pub fn from_bytes(reader: &mut BufferReader) -> Result<CharacterJoinedTeam, AppMessagesError> {
        let character_id = reader.read_u64()?;
        let team_name = reader.read_string()?;
        let team_colors_len = reader.read_u16()?;
        let mut team_colors: Vec<Color> = Vec::new();
        for _ in 0..team_colors_len {
            let el = Color::from_bytes(reader)?;
            team_colors.push(el);
        }
        let role = reader.read_i16()?;
        let role = TeamRole::try_from(role)?;
        Ok(CharacterJoinedTeam {character_id, team_name, team_colors, role})
    }

    pub fn write_bytes(&self, writer: &mut Vec<u8>, tag: bool) {
        if tag {
            writer.push(3_u8);
        }
        writer.extend(self.character_id.to_le_bytes());
        writer.extend((self.team_name.len() as u8).to_le_bytes());
        writer.extend(self.team_name.as_bytes());
        writer.extend((self.team_colors.len() as u16).to_le_bytes());
        for el in &self.team_colors {
            el.write_bytes(writer);
        }
        writer.extend((self.role as i16).to_le_bytes());
    }
}
